1. Parsing
2. Map
3. Player
4. Keyboard
5. Raycasting
6. Sprites, textures


projection plane = 1920x1080
+FOV = 60 - угол обзора
+POV - направление взгляда
центр of projection plane = 960,540
расстояние до projection plane = width / тангенс половины FOV - 1920/2/(tan30)
угол между соседними лучами = FOV / width = 60/1920

Крайний левый луч POV-(FOV/2)
Крайний правый луч POV+(FOV/2)

Переход от луча к лучу +FOV/width

Алгоритм построения проекции:
1. Вычитаем из ПОВ половину ФОВ - это угол нашего текущего луча
2. Начиная от 0 столбца кастуем лучи из координат игрока в направлении  ПОВ
   - идем лучом, пока не встетим стенку
   - запоминаем длинну полученного луча
3. Добавляем к углу текущего луча FOV/width
4. И так все столбцы до конца

Способ высчитать длинну луча:

Теперь более подробный алгоритм. ВНИМА-
НИЕ! Помните  про используемую систему ко-
ординат! По  оси Y  положительные значения
 находятся СНИЗУ, отрицательные - СВЕРХУ!

 Трассировка  для горизонтальных пересе-
 чений (координаты игрока Py,Px; координаты
  проверяемой точки Ay,Ax):
   1. Находим  первое  ближайшее  пересече-
 ние (точка  А ).  Если  луч  идёт  вверх -
 Ay = int (Py / 64) * 64 - 1;  если  вниз -
 Ay = int (Py / 64) * 64 + 64. Ax находится
 после  вычисления Ay:  Ax = Px + (Py-Ay) /
  / tan(угол луча).
   2. Находим Ya. Оно  равно высоте клетки,
 то есть 64  в нашем  случае. Если луч надо
 трассировать  вверх - Ya должно быть отри-
  цательным, если вниз - положительным.
    3. Находим Xa. Xa = 64/tan(угол луча).
   4. Проверяем пересечение на наличие сте-
 нки. Для проверки нужно текущие координаты
 преобразовать  в координаты  клеток  -  то
 есть,разделить на размер клетки (сдвигом),
 в нашем  случае проверить клетку в коорди-
 натах Ay/64, Ax/64. Если стенка есть - за-
 поминаем  расстояние  от  Py,Px до Ay,Ax и
  прекращаем цикл.
   5. Если  стены нет - переходим к следую-
 щему  пересечению. Ax=Ax+Xa,  Ay=Ay+Ya,  и
 так до победного.
    Трассировка  для вертикальных пересече-
 ний не сильно отличается (координаты игро-
 ка Py,Px; координаты проверяемой точки By,
  Bx):
   1. Находим  первое  ближайшее  пересече-
 ние (точка  B ). Если  луч  идёт  вправо -
 Bx = int (Px / 64) * 64 + 64; если влево -
 Bx = int (Px / 64) * 64 - 1.  Далее,  By =
  = Py + (Px - Bx) * tan(угол луча).
   2. Находим  Xa. Оно равно ширине клетки,
 то  есть  64 в нашем случае. Если луч надо
 трассировать  влево - Xa должно быть отри-
  цательным,если вправо - положительным.
    3. Находим Ya. Ya = 64 * tan(угол луча).
   4. Проверяем пересечение на наличие сте-
 нки. Если стенка есть - запоминаем рассто-
  яние от Py,Px до By,Bx и прекращаем цикл.
   5. Если  стены нет - переходим к следую-
 щему пересечению. Bx = Bx+Xa, By = By+Ya.
    После двух трассировок выбираем ту точ-
 ку, которая  ближе (сравнив найденные рас-
 стояния),для неё и будем рисовать столбец.
 В приведённом на картинках примере это бу-
 дет точка E.
    Нужно бы подробнее рассказать о том,как
 найти расстояние от игрока до стенки. Есть
 несколько способов. Расскажу о двух. Недо-
 статок их в том, что в одном нужно считать
 квадратный корень,а в другом - синус и ко-
 синус. Можно и просто посчитать расстояние
 (X=X2-X1, Y=Y2-Y1), но будет сложнее боро-
 ться  с  искажениями (о  них - в следующем
 разделе).
    Первый способ - расстояние от Px, Py до
 конечной точки Ex, Ey = sqrt ( (Px-Ex)^2 +
 + (Py-Ey)^2 ). Этот  способ  неудобен тем,
 что много медленных операций - два умноже-
 ния и взятие квадратного корня.
    Второй  способ - расстояние = abs (Px -
 Ex)/cos(a) = abs (Py - Ey)/sin(a), где a =
 угол луча. Этот способ удобнее тем,что та-
 бличку  косинуса  и синуса можно посчитать
 заранее,а из медленных операций - одно де-
 ление.
    После  того, как мы нашли расстояние до
 столбцов, можно уже и приступить к отрисо-
 вке проекции.
